#!/usr/bin/env ruby

require "digest"
require "parallel"

# The idea of this function is reduce the search space of possible anagrams
# The function will take wordlist of 99175 words, then reduce it to 1659 words
# How it works:
# This method will take a file path for raw list of words and known_anagram
# Then it will create a map of the characters of the known_anagram
# Using this map we can check every word in the file if it contains the required characters
# Condition for valid words are:
#  - It should *not* have a character not exists in the known_anagram characters
#  - It should *not* have a character repeated more times than in the known_anagram characters
def get_possible_words(file_path, known_anagram)
  possible_words = {}
  possible_chars = {}
  known_anagram.each_char do |c|
    possible_chars[c] = possible_chars.key?(c) ? possible_chars[c] + 1 : 1;
  end

  IO.foreach(file_path).each do |word|
    word.chomp!
    chars = {}
    word.each_char do |c|
      chars[c] = chars.key?(c) ? chars[c] + 1 : 1;
    end

    is_possible_word = true
    chars.keys.each do |c|
      if !possible_chars.key?(c) || chars[c] > possible_chars[c]
        is_possible_word = false
        break
      end
    end

    possible_words[word] = 1 if is_possible_word
  end

  possible_words
end

# The idea is of this function is we can create a hash table of the known anagram. Then using this
# hash table we can create a hash for every phrase and compare them.
# The hash table is generated with every character mapped to prime number starting from 3.
def get_hash_table(str)
  table = {}
  current = 3
  str.split("").sort.uniq.each do |c|
    table[c] = current
    current += 3
  end
  table
end

# This function will hash a string to a number using the hash_table generated by get_hash_table
def get_hash(str, hash_table)
  value = 1
  str.each_char do |c|
    return 0 unless hash_table.key?(c)
    value *= hash_table[c]
  end
  value
end

# This function is where search for a hash happens. It has O(n^3) complexity. N = number of reduced
# list of words. Using get_possible_words we reduce N from 99175 to 1659 but it is still large ! so
# we use parallel distribute the computation across all cores.
# Roughly it will do 4.5 billion iteration, which is on DigitalOcean 24 core instance will take ~5min.
# To make each iteration faster we apply the following conditions in this order
# - Skip the phrase if its length != the length of known_anagram
# - Skip the phrase if it is not an anagram. We check this by comparing the hash
# - Skip the phrase if its md5 does not the one we are looking for
#
# Note: This function has flow. We assume that the search space should be a phrase with three words
# & two spaces. However the third hash 665e5bcb0c20062fe8abaaf4628bb154 maps to "wu lisp not statutory"
# so it will not be able to find this hash.
def find_hash(possible_words, known_anagram, known_md5s, start, n = 3)
  cpus = Parallel.processor_count
  puts "Total number of iteration: #{possible_words.length**n}"
  puts "You got #{cpus} cores"

  hash_table = get_hash_table(known_anagram)
  known_hash = get_hash(known_anagram, hash_table)

  Parallel.map(possible_words, in_processes: cpus) do |w1|
    possible_words.each do |w2|
      possible_words.each do |w3|
        # Print every ten million iteration
        phrase = "#{w1} #{w2} #{w3}"

        # Allow only equal size phrases
        next unless phrase.length == known_anagram.length

        # Allow only equal hash phrases
        hash = get_hash(phrase, hash_table)
        next unless hash == known_hash

        # All only equal md5 phrases
        md5 = Digest::MD5.hexdigest phrase
        next unless known_md5s.include?(md5)

        puts "#{phrase} #{md5} (#{Time.now - start}s)"
      end
    end
  end
end

known_anagram = "poultry outwits ants"
known_md5s = [
  "e4820b45d2277f3844eac66c903e84be",
  "23170acc097c24edb98fc5488ab033fe",
  "665e5bcb0c20062fe8abaaf4628bb154"
]

start = Time.now
possible_words = get_possible_words(ARGV[0], known_anagram).keys

find_hash(possible_words, known_anagram, known_md5s, start)
puts "Total time #{(Time.now - start) / 60} min"
